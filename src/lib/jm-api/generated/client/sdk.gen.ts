// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';
import type { TokenData, TokenResponses, TokenErrors, CreatewalletData, CreatewalletResponses, CreatewalletErrors, RecoverwalletData, RecoverwalletResponses, RecoverwalletErrors, UnlockwalletData, UnlockwalletResponses, UnlockwalletErrors, LockwalletData, LockwalletResponses, LockwalletErrors, DisplaywalletData, DisplaywalletResponses, DisplaywalletErrors, SessionData, SessionResponses, SessionErrors, VersionData, VersionResponses, ListwalletsData, ListwalletsResponses, ListwalletsErrors, YieldgenreportData, YieldgenreportResponses, YieldgenreportErrors, GetaddressData, GetaddressResponses, GetaddressErrors, RescanblockchainData, RescanblockchainResponses, RescanblockchainErrors, GetrescaninfoData, GetrescaninfoResponses, GetrescaninfoErrors, GettimelockaddressData, GettimelockaddressResponses, GettimelockaddressErrors, ListutxosData, ListutxosResponses, ListutxosErrors, DirectsendData, DirectsendResponses, DirectsendErrors, StartmakerData, StartmakerResponses, StartmakerErrors, StopmakerData, StopmakerResponses, StopmakerErrors, DocoinjoinData, DocoinjoinResponses, DocoinjoinErrors, GetscheduleData, GetscheduleResponses, GetscheduleErrors, RunscheduleData, RunscheduleResponses, RunscheduleErrors, StopcoinjoinData, StopcoinjoinResponses, StopcoinjoinErrors, ConfigsettingData, ConfigsettingResponses, ConfigsettingErrors, ConfiggetData, ConfiggetResponses, ConfiggetErrors, FreezeData, FreezeResponses, FreezeErrors, GetseedData, GetseedResponses, GetseedErrors } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * The token endpoint is used by the client to obtain an access token using a grant such as refresh token
 * Give a refresh token and get back both an access and refresh token. On initially creating, unlocking or recovering a wallet, store both the refresh and access tokens, the latter is valid for only 30 minutes (must be used for any authenticated call) while the former is for 4 hours (can only be used in the refresh request parameters). Use /token endpoint on a regular basis to get new access and refresh tokens, ideally before access token expiration to avoid authentication errors and in any case, before refresh token expiration. The newly issued tokens must be used in subsequent calls since operation invalidates previously issued tokens.
 *
 */
export const token = <ThrowOnError extends boolean = false>(options?: Options<TokenData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<TokenResponses, TokenErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/token',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * create a new wallet
 * Give a filename (.jmdat must be included) and a password, create the wallet and get back the seedphrase for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. Note that this operation cannot be performed when a wallet is already loaded (unlocked).
 */
export const createwallet = <ThrowOnError extends boolean = false>(options?: Options<CreatewalletData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<CreatewalletResponses, CreatewalletErrors, ThrowOnError>({
        url: '/wallet/create',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * recover a wallet from a seedphrase
 * Give a filename (.jmdat must be included), a wallettype, a seedphrase and a password, create the wallet for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. The seedphrase must be a single string with words space-separated, and must conform to BIP39 (else 400 is returned). Note that this operation cannot be performed when a wallet is already loaded (unlocked).
 */
export const recoverwallet = <ThrowOnError extends boolean = false>(options?: Options<RecoverwalletData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<RecoverwalletResponses, RecoverwalletErrors, ThrowOnError>({
        url: '/wallet/recover',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * decrypt an existing wallet
 * Give the password for the specified (existing) wallet file, and it will be decrypted ready for use. Note that this operation cannot be performed when another wallet is already loaded (unlocked).
 */
export const unlockwallet = <ThrowOnError extends boolean = false>(options: Options<UnlockwalletData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<UnlockwalletResponses, UnlockwalletErrors, ThrowOnError>({
        url: '/wallet/{walletname}/unlock',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * block access to a currently decrypted wallet
 * After this (authenticated) action, the wallet will not be readable or writeable.
 */
export const lockwallet = <ThrowOnError extends boolean = false>(options: Options<LockwalletData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<LockwalletResponses, LockwalletErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/lock',
        ...options
    });
};

/**
 * get detailed breakdown of wallet contents by account.
 * get detailed breakdown of wallet contents by account.
 */
export const displaywallet = <ThrowOnError extends boolean = false>(options: Options<DisplaywalletData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<DisplaywalletResponses, DisplaywalletErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/display',
        ...options
    });
};

/**
 * get current status of backend
 * get whether a wallet is loaded and whether coinjoin/maker are happening. if an auth token is provided, which is optional, it will be validated.
 */
export const session = <ThrowOnError extends boolean = false>(options?: Options<SessionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<SessionResponses, SessionErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/session',
        ...options
    });
};

/**
 * get info on backend
 * get information about backend, including the version of Joinmarket running.
 */
export const version = <ThrowOnError extends boolean = false>(options?: Options<VersionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<VersionResponses, unknown, ThrowOnError>({
        url: '/getinfo',
        ...options
    });
};

/**
 * get current available wallets
 * get all wallet filenames in standard location as a list
 */
export const listwallets = <ThrowOnError extends boolean = false>(options?: Options<ListwalletsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<ListwalletsResponses, ListwalletsErrors, ThrowOnError>({
        url: '/wallet/all',
        ...options
    });
};

/**
 * get latest report on yield generating activity
 * Get list of coinjoins taken part in as maker (across all wallets). Data returned as list of strings, each one in the same comma separated format as found in yigen-statement.csv. Note that this returns all lines in the file, including the lines that are only present to represent the starting of a bot. Those lines contain the word Connected and can be thus discarded. The header line is also delivered and so can be ignored as per the client requirements.
 *
 */
export const yieldgenreport = <ThrowOnError extends boolean = false>(options?: Options<YieldgenreportData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<YieldgenreportResponses, YieldgenreportErrors, ThrowOnError>({
        url: '/wallet/yieldgen/report',
        ...options
    });
};

/**
 * get a fresh address in the given account for depositing funds.
 * get a fresh address in the given account for depositing funds.
 */
export const getaddress = <ThrowOnError extends boolean = false>(options: Options<GetaddressData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetaddressResponses, GetaddressErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/address/new/{mixdepth}',
        ...options
    });
};

/**
 * Rescan the blockchain from a given blockheight
 * Use this operation on recovered wallets to re-sync the wallet
 */
export const rescanblockchain = <ThrowOnError extends boolean = false>(options: Options<RescanblockchainData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<RescanblockchainResponses, RescanblockchainErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/rescanblockchain/{blockheight}',
        ...options
    });
};

/**
 * get the current rescan status
 * get the current rescan status
 */
export const getrescaninfo = <ThrowOnError extends boolean = false>(options: Options<GetrescaninfoData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetrescaninfoResponses, GetrescaninfoErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/getrescaninfo',
        ...options
    });
};

/**
 * get a fresh timelock address
 * get a new timelocked address, for depositing funds, to create a fidelity bond, which will automatically be used when the maker is started. specify the date in YYYY-mm as the last path parameter. Note that mixdepth is not specified as timelock addresses are always in mixdepth(account) zero.
 */
export const gettimelockaddress = <ThrowOnError extends boolean = false>(options: Options<GettimelockaddressData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GettimelockaddressResponses, GettimelockaddressErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/address/timelock/new/{lockdate}',
        ...options
    });
};

/**
 * list details of all utxos currently in the wallet.
 * list details of all utxos currently in the wallet.
 */
export const listutxos = <ThrowOnError extends boolean = false>(options: Options<ListutxosData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<ListutxosResponses, ListutxosErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/utxos',
        ...options
    });
};

/**
 * create and broadcast a transaction (without coinjoin)
 * create and broadcast a transaction (without coinjoin)
 */
export const directsend = <ThrowOnError extends boolean = false>(options: Options<DirectsendData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<DirectsendResponses, DirectsendErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/taker/direct-send',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Start the yield generator service.
 * Start the yield generator service with the configuration settings specified in the POST request. Note that if fidelity bonds are enabled in the wallet, and a timelock address has been generated, and then funded, the fidelity bond will automatically be advertised without any specific configuration in this request. Note that if the wallet does not have confirmed coins, or another taker or maker coinjoin service is already running, the maker will not start.
 */
export const startmaker = <ThrowOnError extends boolean = false>(options: Options<StartmakerData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<StartmakerResponses, StartmakerErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/maker/start',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * stop the yield generator service
 * stop the yield generator service
 */
export const stopmaker = <ThrowOnError extends boolean = false>(options: Options<StopmakerData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StopmakerResponses, StopmakerErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/maker/stop',
        ...options
    });
};

/**
 * initiate a coinjoin as taker
 * initiate a coinjoin as taker
 */
export const docoinjoin = <ThrowOnError extends boolean = false>(options: Options<DocoinjoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<DocoinjoinResponses, DocoinjoinErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/taker/coinjoin',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * get the schedule that is currently running
 * Get the current transaction schedule if one is running.
 */
export const getschedule = <ThrowOnError extends boolean = false>(options: Options<GetscheduleData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetscheduleResponses, GetscheduleErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/taker/schedule',
        ...options
    });
};

/**
 * create and run a schedule of transactions
 * Creates and then starts a schedule of transactions.
 */
export const runschedule = <ThrowOnError extends boolean = false>(options: Options<RunscheduleData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<RunscheduleResponses, RunscheduleErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/taker/schedule',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * stop a running coinjoin attempt
 * stop a running coinjoin attempt
 */
export const stopcoinjoin = <ThrowOnError extends boolean = false>(options: Options<StopcoinjoinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<StopcoinjoinResponses, StopcoinjoinErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/taker/stop',
        ...options
    });
};

/**
 * change a config variable
 * change a config variable (for the duration of this backend daemon process instance)
 */
export const configsetting = <ThrowOnError extends boolean = false>(options: Options<ConfigsettingData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ConfigsettingResponses, ConfigsettingErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/configset',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * get the value of a specific config setting
 * Get the value of a specific config setting. Note values are always returned as string.
 */
export const configget = <ThrowOnError extends boolean = false>(options: Options<ConfiggetData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<ConfiggetResponses, ConfiggetErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/configget',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * freeze or unfreeze an individual utxo for spending
 * freeze or unfreeze an individual utxo for spending
 */
export const freeze = <ThrowOnError extends boolean = false>(options: Options<FreezeData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<FreezeResponses, FreezeErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/freeze',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * get the mnemonic recovery phrase with the optional passphrase
 * Get the mnemonic recovery phrase with the optional passphrase. Not the response is a sentence with few line breaks.
 */
export const getseed = <ThrowOnError extends boolean = false>(options: Options<GetseedData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetseedResponses, GetseedErrors, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/wallet/{walletname}/getseed',
        ...options
    });
};