// This file is auto-generated by @hey-api/openapi-ts

export type FreezeRequest = {
    'utxo-string': string;
    freeze: boolean;
};

export type ConfigSetRequest = {
    section: string;
    field: string;
    value: string;
};

export type ConfigGetRequest = {
    section: string;
    field: string;
};

export type ConfigGetResponse = {
    configvalue: string;
};

export type ConfigSetResponse = {
    [key: string]: unknown;
};

export type FreezeResponse = {
    [key: string]: unknown;
};

export type DoCoinjoinRequest = {
    mixdepth: number;
    amount_sats: number;
    counterparties: number;
    destination: string;
    /**
     * Bitcoin miner fee to use for transaction. A number higher than 1000 is used as satoshi per kvB tx fee. The number lower than that uses the dynamic fee estimation of blockchain provider as confirmation target.
     */
    txfee?: unknown;
};

export type TokenRequest = {
    grant_type: string;
    refresh_token: string;
};

export type TokenResponse = {
    token: string;
    token_type: string;
    expires_in: number;
    scope: string;
    refresh_token: string;
};

export type RunScheduleRequest = {
    destination_addresses?: Array<string>;
    tumbler_options?: {
        addrcount?: number;
        minmakercount?: number;
        makercountrange?: Array<number>;
        mixdepthcount?: number;
        mintxcount?: number;
        txcountparams?: Array<number>;
        timelambda?: number;
        stage1_timelambda_increase?: number;
        liquiditywait?: number;
        waittime?: number;
        mixdepthsrc?: number;
        restart?: boolean;
        schedulefile?: string;
        mincjamount?: number;
        amtmixdepths?: number;
        rounding_chance?: number;
        rounding_sigfig_weights?: Array<number>;
    };
};

export type StartMakerRequest = {
    txfee: string;
    cjfee_a: string;
    cjfee_r: string;
    ordertype: string;
    minsize: string;
};

export type GetAddressResponse = {
    address: string;
};

export type ListWalletsResponse = {
    wallets?: Array<string>;
};

export type YieldGenReportResponse = Array<string>;

export type GetinfoResponse = {
    version: string;
};

export type RescanBlockchainResponse = {
    walletname: string;
};

export type RescanInfoResponse = {
    rescanning: boolean;
    progress?: number;
};

export type SessionResponse = {
    session: boolean;
    maker_running: boolean;
    coinjoin_in_process: boolean;
    schedule?: Array<Array<string | number>>;
    wallet_name: string;
    offer_list?: Array<{
        oid?: number;
        ordertype?: string;
        minsize?: number;
        maxsize?: number;
        txfee?: number;
        cjfee?: string;
    }>;
    nickname?: string;
    rescanning: boolean;
    block_height?: number;
};

export type ListUtxosResponse = {
    utxos?: Array<{
        utxo?: string;
        address?: string;
        path?: string;
        label?: string;
        value?: number;
        tries?: number;
        tries_remaining?: number;
        external?: boolean;
        mixdepth?: number;
        confirmations?: number;
        frozen?: boolean;
    }>;
};

export type WalletDisplayResponse = {
    walletname: string;
    walletinfo: {
        wallet_name: string;
        total_balance: string;
        available_balance?: string;
        accounts: Array<{
            account?: string;
            account_balance?: string;
            available_balance?: string;
            branches?: Array<{
                branch?: string;
                balance?: string;
                available_balance?: string;
                entries?: Array<{
                    hd_path?: string;
                    address?: string;
                    amount?: string;
                    available_balance?: string;
                    status?: string;
                    label?: string;
                    extradata?: string;
                }>;
            }>;
        }>;
    };
};

export type CreateWalletResponse = {
    walletname: string;
    seedphrase: string;
    token: string;
    refresh_token: string;
};

export type UnlockWalletResponse = {
    walletname: string;
    token: string;
    refresh_token: string;
};

export type DirectSendResponse = {
    txinfo: {
        hex?: string;
        inputs?: Array<{
            outpoint?: string;
            scriptSig?: string;
            nSequence?: number;
            witness?: string;
        }>;
        outputs?: Array<{
            value_sats?: number;
            scriptPubKey?: string;
            address?: string;
        }>;
        txid?: string;
        nLockTime?: number;
        nVersion?: number;
    };
};

export type GetSeedResponse = {
    seedphrase: string;
};

export type GetScheduleResponse = {
    schedule: Array<Array<string | number>>;
};

export type LockWalletResponse = {
    walletname: string;
    already_locked: boolean;
};

export type CreateWalletRequest = {
    walletname: string;
    password: string;
    wallettype: string;
};

export type RecoverWalletRequest = {
    walletname: string;
    password: string;
    wallettype: string;
    seedphrase: string;
};

export type UnlockWalletRequest = {
    password: string;
};

export type DirectSendRequest = {
    mixdepth: number;
    amount_sats: number;
    destination: string;
    /**
     * Bitcoin miner fee to use for transaction. A number higher than 1000 is used as satoshi per kvB tx fee. The number lower than that uses the dynamic fee estimation of blockchain provider as confirmation target.
     */
    txfee?: number;
};

export type ErrorMessage = {
    message?: string;
    error_description?: string;
};

export type TokenData = {
    /**
     * token refresh parameters
     */
    body?: TokenRequest;
    path?: never;
    query?: never;
    url: '/token';
};

export type TokenErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
};

export type TokenError = TokenErrors[keyof TokenErrors];

export type TokenResponses = {
    /**
     * Access token obtained successfully
     */
    200: TokenResponse;
};

export type TokenResponse2 = TokenResponses[keyof TokenResponses];

export type CreatewalletData = {
    /**
     * wallet creation parameters
     */
    body?: CreateWalletRequest;
    path?: never;
    query?: never;
    url: '/wallet/create';
};

export type CreatewalletErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Unable to complete request because object already exists.
     */
    409: ErrorMessage;
};

export type CreatewalletError = CreatewalletErrors[keyof CreatewalletErrors];

export type CreatewalletResponses = {
    /**
     * wallet created successfully
     */
    201: CreateWalletResponse;
};

export type CreatewalletResponse = CreatewalletResponses[keyof CreatewalletResponses];

export type RecoverwalletData = {
    /**
     * wallet recovery parameters
     */
    body?: RecoverWalletRequest;
    path?: never;
    query?: never;
    url: '/wallet/recover';
};

export type RecoverwalletErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Unable to complete request because object already exists.
     */
    409: ErrorMessage;
};

export type RecoverwalletError = RecoverwalletErrors[keyof RecoverwalletErrors];

export type RecoverwalletResponses = {
    /**
     * wallet created successfully
     */
    201: CreateWalletResponse;
};

export type RecoverwalletResponse = RecoverwalletResponses[keyof RecoverwalletResponses];

export type UnlockwalletData = {
    /**
     * wallet unlocking parameters
     */
    body?: UnlockWalletRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/unlock';
};

export type UnlockwalletErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
    /**
     * Unable to complete request because object already exists.
     */
    409: ErrorMessage;
};

export type UnlockwalletError = UnlockwalletErrors[keyof UnlockwalletErrors];

export type UnlockwalletResponses = {
    /**
     * wallet unlocked successfully
     */
    200: UnlockWalletResponse;
};

export type UnlockwalletResponse = UnlockwalletResponses[keyof UnlockwalletResponses];

export type LockwalletData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/lock';
};

export type LockwalletErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
};

export type LockwalletError = LockwalletErrors[keyof LockwalletErrors];

export type LockwalletResponses = {
    /**
     * wallet locked successfully
     */
    200: LockWalletResponse;
};

export type LockwalletResponse = LockwalletResponses[keyof LockwalletResponses];

export type DisplaywalletData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/display';
};

export type DisplaywalletErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type DisplaywalletError = DisplaywalletErrors[keyof DisplaywalletErrors];

export type DisplaywalletResponses = {
    /**
     * wallet display contents retrieved successfully.
     */
    200: WalletDisplayResponse;
};

export type DisplaywalletResponse = DisplaywalletResponses[keyof DisplaywalletResponses];

export type SessionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/session';
};

export type SessionErrors = {
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type SessionError = SessionErrors[keyof SessionErrors];

export type SessionResponses = {
    /**
     * successful heartbeat response
     */
    200: SessionResponse;
};

export type SessionResponse2 = SessionResponses[keyof SessionResponses];

export type VersionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/getinfo';
};

export type VersionResponses = {
    /**
     * successful Joinmarket getinfo response
     */
    200: GetinfoResponse;
};

export type VersionResponse = VersionResponses[keyof VersionResponses];

export type ListwalletsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/all';
};

export type ListwalletsErrors = {
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type ListwalletsError = ListwalletsErrors[keyof ListwalletsErrors];

export type ListwalletsResponses = {
    /**
     * successful response to listwallets
     */
    200: ListWalletsResponse;
};

export type ListwalletsResponse = ListwalletsResponses[keyof ListwalletsResponses];

export type YieldgenreportData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/wallet/yieldgen/report';
};

export type YieldgenreportErrors = {
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type YieldgenreportError = YieldgenreportErrors[keyof YieldgenreportErrors];

export type YieldgenreportResponses = {
    /**
     * get list of coinjoins taken part in as maker (across all wallets)
     */
    200: YieldGenReportResponse;
};

export type YieldgenreportResponse = YieldgenreportResponses[keyof YieldgenreportResponses];

export type GetaddressData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
        /**
         * account or mixdepth to source the address from (0..4)
         */
        mixdepth: string;
    };
    query?: never;
    url: '/wallet/{walletname}/address/new/{mixdepth}';
};

export type GetaddressErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type GetaddressError = GetaddressErrors[keyof GetaddressErrors];

export type GetaddressResponses = {
    /**
     * successful retrieval of new address
     */
    200: GetAddressResponse;
};

export type GetaddressResponse = GetaddressResponses[keyof GetaddressResponses];

export type RescanblockchainData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
        /**
         * starting block height for the rescan
         */
        blockheight: number;
    };
    query?: never;
    url: '/wallet/{walletname}/rescanblockchain/{blockheight}';
};

export type RescanblockchainErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type RescanblockchainError = RescanblockchainErrors[keyof RescanblockchainErrors];

export type RescanblockchainResponses = {
    /**
     * Blockchain rescan started successfully
     */
    200: RescanBlockchainResponse;
};

export type RescanblockchainResponse = RescanblockchainResponses[keyof RescanblockchainResponses];

export type GetrescaninfoData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/getrescaninfo';
};

export type GetrescaninfoErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type GetrescaninfoError = GetrescaninfoErrors[keyof GetrescaninfoErrors];

export type GetrescaninfoResponses = {
    /**
     * Blockchain rescan status retrieved successfully
     */
    200: RescanInfoResponse;
};

export type GetrescaninfoResponse = GetrescaninfoResponses[keyof GetrescaninfoResponses];

export type GettimelockaddressData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
        /**
         * month whose first day will be the end of the timelock, for this address.
         */
        lockdate: string;
    };
    query?: never;
    url: '/wallet/{walletname}/address/timelock/new/{lockdate}';
};

export type GettimelockaddressErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type GettimelockaddressError = GettimelockaddressErrors[keyof GettimelockaddressErrors];

export type GettimelockaddressResponses = {
    /**
     * successful retrieval of new address
     */
    200: GetAddressResponse;
};

export type GettimelockaddressResponse = GettimelockaddressResponses[keyof GettimelockaddressResponses];

export type ListutxosData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/utxos';
};

export type ListutxosErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type ListutxosError = ListutxosErrors[keyof ListutxosErrors];

export type ListutxosResponses = {
    /**
     * successful retrieval of utxo list
     */
    200: ListUtxosResponse;
};

export type ListutxosResponse = ListutxosResponses[keyof ListutxosResponses];

export type DirectsendData = {
    /**
     * transaction creation parameters
     */
    body?: DirectSendRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/taker/direct-send';
};

export type DirectsendErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
    /**
     * Transaction failed to broadcast.
     */
    409: ErrorMessage;
};

export type DirectsendError = DirectsendErrors[keyof DirectsendErrors];

export type DirectsendResponses = {
    /**
     * transaction broadcast OK.
     */
    200: DirectSendResponse;
};

export type DirectsendResponse = DirectsendResponses[keyof DirectsendResponses];

export type StartmakerData = {
    /**
     * yield generator config parameters
     */
    body?: StartMakerRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/maker/start';
};

export type StartmakerErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
    /**
     * Maker could not start without confirmed balance.
     */
    409: ErrorMessage;
    /**
     * The server is not ready to process the request.
     */
    503: ErrorMessage;
};

export type StartmakerError = StartmakerErrors[keyof StartmakerErrors];

export type StartmakerResponses = {
    /**
     * The request has been submitted successfully for processing, but the processing has not been completed.
     */
    202: unknown;
};

export type StopmakerData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/maker/stop';
};

export type StopmakerErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type StopmakerError = StopmakerErrors[keyof StopmakerErrors];

export type StopmakerResponses = {
    /**
     * The request has been submitted successfully for processing, but the processing has not been completed.
     */
    202: unknown;
};

export type DocoinjoinData = {
    /**
     * taker side coinjoin parameters
     */
    body?: DoCoinjoinRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/taker/coinjoin';
};

export type DocoinjoinErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
    /**
     * Unable to complete request because config settings are missing.
     */
    409: ErrorMessage;
    /**
     * The server is not ready to process the request.
     */
    503: ErrorMessage;
};

export type DocoinjoinError = DocoinjoinErrors[keyof DocoinjoinErrors];

export type DocoinjoinResponses = {
    /**
     * The request has been submitted successfully for processing, but the processing has not been completed.
     */
    202: unknown;
};

export type GetscheduleData = {
    body?: never;
    path: {
        /**
         * name of the wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/taker/schedule';
};

export type GetscheduleErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type GetscheduleError = GetscheduleErrors[keyof GetscheduleErrors];

export type GetscheduleResponses = {
    /**
     * schedule retrieved successfully
     */
    200: GetScheduleResponse;
};

export type GetscheduleResponse = GetscheduleResponses[keyof GetscheduleResponses];

export type RunscheduleData = {
    /**
     * taker side schedule parameters
     */
    body?: RunScheduleRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/taker/schedule';
};

export type RunscheduleErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
    /**
     * Unable to complete request because config settings are missing.
     */
    409: ErrorMessage;
    /**
     * The server is not ready to process the request.
     */
    503: ErrorMessage;
};

export type RunscheduleError = RunscheduleErrors[keyof RunscheduleErrors];

export type RunscheduleResponses = {
    /**
     * schedule started successfully
     */
    202: GetScheduleResponse;
};

export type RunscheduleResponse = RunscheduleResponses[keyof RunscheduleResponses];

export type StopcoinjoinData = {
    body?: never;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/taker/stop';
};

export type StopcoinjoinErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to authorise the credentials that were supplied.
     */
    401: ErrorMessage;
    /**
     * Item not found.
     */
    404: ErrorMessage;
};

export type StopcoinjoinError = StopcoinjoinErrors[keyof StopcoinjoinErrors];

export type StopcoinjoinResponses = {
    /**
     * The request has been submitted successfully for processing, but the processing has not been completed.
     */
    202: unknown;
};

export type ConfigsettingData = {
    /**
     * config editing parameters
     */
    body?: ConfigSetRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/configset';
};

export type ConfigsettingErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to complete request because config settings are missing.
     */
    409: ErrorMessage;
};

export type ConfigsettingError = ConfigsettingErrors[keyof ConfigsettingErrors];

export type ConfigsettingResponses = {
    /**
     * successful update of config value
     */
    200: ConfigSetResponse;
};

export type ConfigsettingResponse = ConfigsettingResponses[keyof ConfigsettingResponses];

export type ConfiggetData = {
    body?: ConfigGetRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/configget';
};

export type ConfiggetErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
    /**
     * Unable to complete request because config settings are missing.
     */
    409: ErrorMessage;
};

export type ConfiggetError = ConfiggetErrors[keyof ConfiggetErrors];

export type ConfiggetResponses = {
    /**
     * successful retrieval of config value
     */
    200: ConfigGetResponse;
};

export type ConfiggetResponse = ConfiggetResponses[keyof ConfiggetResponses];

export type FreezeData = {
    /**
     * utxo string and freeze toggle as boolean
     */
    body?: FreezeRequest;
    path: {
        /**
         * name of wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/freeze';
};

export type FreezeErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
};

export type FreezeError = FreezeErrors[keyof FreezeErrors];

export type FreezeResponses = {
    /**
     * freeze or unfreeze utxo action completed successfully
     */
    200: FreezeResponse;
};

export type FreezeResponse2 = FreezeResponses[keyof FreezeResponses];

export type GetseedData = {
    body?: never;
    path: {
        /**
         * name of the wallet including .jmdat
         */
        walletname: string;
    };
    query?: never;
    url: '/wallet/{walletname}/getseed';
};

export type GetseedErrors = {
    /**
     * Bad request format.
     */
    400: ErrorMessage;
};

export type GetseedError = GetseedErrors[keyof GetseedErrors];

export type GetseedResponses = {
    /**
     * seedphrase retrieved successfully
     */
    200: GetSeedResponse;
};

export type GetseedResponse = GetseedResponses[keyof GetseedResponses];

export type ClientOptions = {
    baseUrl: 'https://none' | (string & {});
};