// This file is auto-generated by @hey-api/openapi-ts
import { type UseMutationOptions, queryOptions } from '@tanstack/react-query'

import { client as _heyApiClient } from '../client.gen'
import {
  type Options,
  configget,
  configsetting,
  createwallet,
  directsend,
  displaywallet,
  docoinjoin,
  freeze,
  getaddress,
  getrescaninfo,
  getschedule,
  getseed,
  gettimelockaddress,
  listutxos,
  listwallets,
  lockwallet,
  recoverwallet,
  rescanblockchain,
  runschedule,
  session,
  startmaker,
  stopcoinjoin,
  stopmaker,
  token,
  unlockwallet,
  version,
  yieldgenreport,
} from '../sdk.gen'
import type {
  ConfiggetData,
  ConfiggetError,
  ConfiggetResponse,
  ConfigsettingData,
  ConfigsettingError,
  ConfigsettingResponse,
  CreatewalletData,
  CreatewalletError,
  CreatewalletResponse,
  DirectsendData,
  DirectsendError,
  DirectsendResponse,
  DisplaywalletData,
  DocoinjoinData,
  DocoinjoinError,
  FreezeData,
  FreezeError,
  FreezeResponse2,
  GetaddressData,
  GetrescaninfoData,
  GetscheduleData,
  GetseedData,
  GettimelockaddressData,
  ListutxosData,
  ListwalletsData,
  LockwalletData,
  RecoverwalletData,
  RecoverwalletError,
  RecoverwalletResponse,
  RescanblockchainData,
  RunscheduleData,
  RunscheduleError,
  RunscheduleResponse,
  SessionData,
  StartmakerData,
  StartmakerError,
  StopcoinjoinData,
  StopmakerData,
  TokenData,
  TokenError,
  TokenResponse2,
  UnlockwalletData,
  UnlockwalletError,
  UnlockwalletResponse,
  VersionData,
  YieldgenreportData,
} from '../types.gen'

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string
    _infinite?: boolean
  },
]

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0]
  if (infinite) {
    params._infinite = infinite
  }
  if (options?.body) {
    params.body = options.body
  }
  if (options?.headers) {
    params.headers = options.headers
  }
  if (options?.path) {
    params.path = options.path
  }
  if (options?.query) {
    params.query = options.query
  }
  return [params]
}

export const tokenQueryKey = (options?: Options<TokenData>) => createQueryKey('token', options)

/**
 * The token endpoint is used by the client to obtain an access token using a grant such as refresh token
 * Give a refresh token and get back both an access and refresh token. On initially creating, unlocking or recovering a wallet, store both the refresh and access tokens, the latter is valid for only 30 minutes (must be used for any authenticated call) while the former is for 4 hours (can only be used in the refresh request parameters). Use /token endpoint on a regular basis to get new access and refresh tokens, ideally before access token expiration to avoid authentication errors and in any case, before refresh token expiration. The newly issued tokens must be used in subsequent calls since operation invalidates previously issued tokens.
 *
 */
export const tokenOptions = (options?: Options<TokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await token({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: tokenQueryKey(options),
  })
}

/**
 * The token endpoint is used by the client to obtain an access token using a grant such as refresh token
 * Give a refresh token and get back both an access and refresh token. On initially creating, unlocking or recovering a wallet, store both the refresh and access tokens, the latter is valid for only 30 minutes (must be used for any authenticated call) while the former is for 4 hours (can only be used in the refresh request parameters). Use /token endpoint on a regular basis to get new access and refresh tokens, ideally before access token expiration to avoid authentication errors and in any case, before refresh token expiration. The newly issued tokens must be used in subsequent calls since operation invalidates previously issued tokens.
 *
 */
export const tokenMutation = (
  options?: Partial<Options<TokenData>>,
): UseMutationOptions<TokenResponse2, TokenError, Options<TokenData>> => {
  const mutationOptions: UseMutationOptions<TokenResponse2, TokenError, Options<TokenData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await token({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const createwalletQueryKey = (options?: Options<CreatewalletData>) => createQueryKey('createwallet', options)

/**
 * create a new wallet
 * Give a filename (.jmdat must be included) and a password, create the wallet and get back the seedphrase for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. Note that this operation cannot be performed when a wallet is already loaded (unlocked).
 */
export const createwalletOptions = (options?: Options<CreatewalletData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await createwallet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: createwalletQueryKey(options),
  })
}

/**
 * create a new wallet
 * Give a filename (.jmdat must be included) and a password, create the wallet and get back the seedphrase for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. Note that this operation cannot be performed when a wallet is already loaded (unlocked).
 */
export const createwalletMutation = (
  options?: Partial<Options<CreatewalletData>>,
): UseMutationOptions<CreatewalletResponse, CreatewalletError, Options<CreatewalletData>> => {
  const mutationOptions: UseMutationOptions<CreatewalletResponse, CreatewalletError, Options<CreatewalletData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await createwallet({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const recoverwalletQueryKey = (options?: Options<RecoverwalletData>) => createQueryKey('recoverwallet', options)

/**
 * recover a wallet from a seedphrase
 * Give a filename (.jmdat must be included), a wallettype, a seedphrase and a password, create the wallet for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. The seedphrase must be a single string with words space-separated, and must conform to BIP39 (else 400 is returned). Note that this operation cannot be performed when a wallet is already loaded (unlocked).
 */
export const recoverwalletOptions = (options?: Options<RecoverwalletData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await recoverwallet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: recoverwalletQueryKey(options),
  })
}

/**
 * recover a wallet from a seedphrase
 * Give a filename (.jmdat must be included), a wallettype, a seedphrase and a password, create the wallet for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. The seedphrase must be a single string with words space-separated, and must conform to BIP39 (else 400 is returned). Note that this operation cannot be performed when a wallet is already loaded (unlocked).
 */
export const recoverwalletMutation = (
  options?: Partial<Options<RecoverwalletData>>,
): UseMutationOptions<RecoverwalletResponse, RecoverwalletError, Options<RecoverwalletData>> => {
  const mutationOptions: UseMutationOptions<RecoverwalletResponse, RecoverwalletError, Options<RecoverwalletData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await recoverwallet({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const unlockwalletQueryKey = (options: Options<UnlockwalletData>) => createQueryKey('unlockwallet', options)

/**
 * decrypt an existing wallet
 * Give the password for the specified (existing) wallet file, and it will be decrypted ready for use. Note that this operation cannot be performed when another wallet is already loaded (unlocked).
 */
export const unlockwalletOptions = (options: Options<UnlockwalletData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await unlockwallet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: unlockwalletQueryKey(options),
  })
}

/**
 * decrypt an existing wallet
 * Give the password for the specified (existing) wallet file, and it will be decrypted ready for use. Note that this operation cannot be performed when another wallet is already loaded (unlocked).
 */
export const unlockwalletMutation = (
  options?: Partial<Options<UnlockwalletData>>,
): UseMutationOptions<UnlockwalletResponse, UnlockwalletError, Options<UnlockwalletData>> => {
  const mutationOptions: UseMutationOptions<UnlockwalletResponse, UnlockwalletError, Options<UnlockwalletData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await unlockwallet({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const lockwalletQueryKey = (options: Options<LockwalletData>) => createQueryKey('lockwallet', options)

/**
 * block access to a currently decrypted wallet
 * After this (authenticated) action, the wallet will not be readable or writeable.
 */
export const lockwalletOptions = (options: Options<LockwalletData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await lockwallet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: lockwalletQueryKey(options),
  })
}

export const displaywalletQueryKey = (options: Options<DisplaywalletData>) => createQueryKey('displaywallet', options)

/**
 * get detailed breakdown of wallet contents by account.
 * get detailed breakdown of wallet contents by account.
 */
export const displaywalletOptions = (options: Options<DisplaywalletData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await displaywallet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: displaywalletQueryKey(options),
  })
}

export const sessionQueryKey = (options?: Options<SessionData>) => createQueryKey('session', options)

/**
 * get current status of backend
 * get whether a wallet is loaded and whether coinjoin/maker are happening. if an auth token is provided, which is optional, it will be validated.
 */
export const sessionOptions = (options?: Options<SessionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await session({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: sessionQueryKey(options),
  })
}

export const versionQueryKey = (options?: Options<VersionData>) => createQueryKey('version', options)

/**
 * get info on backend
 * get information about backend, including the version of Joinmarket running.
 */
export const versionOptions = (options?: Options<VersionData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await version({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: versionQueryKey(options),
  })
}

export const listwalletsQueryKey = (options?: Options<ListwalletsData>) => createQueryKey('listwallets', options)

/**
 * get current available wallets
 * get all wallet filenames in standard location as a list
 */
export const listwalletsOptions = (options?: Options<ListwalletsData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listwallets({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: listwalletsQueryKey(options),
  })
}

export const yieldgenreportQueryKey = (options?: Options<YieldgenreportData>) =>
  createQueryKey('yieldgenreport', options)

/**
 * get latest report on yield generating activity
 * Get list of coinjoins taken part in as maker (across all wallets). Data returned as list of strings, each one in the same comma separated format as found in yigen-statement.csv. Note that this returns all lines in the file, including the lines that are only present to represent the starting of a bot. Those lines contain the word Connected and can be thus discarded. The header line is also delivered and so can be ignored as per the client requirements.
 *
 */
export const yieldgenreportOptions = (options?: Options<YieldgenreportData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await yieldgenreport({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: yieldgenreportQueryKey(options),
  })
}

export const getaddressQueryKey = (options: Options<GetaddressData>) => createQueryKey('getaddress', options)

/**
 * get a fresh address in the given account for depositing funds.
 * get a fresh address in the given account for depositing funds.
 */
export const getaddressOptions = (options: Options<GetaddressData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getaddress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getaddressQueryKey(options),
  })
}

export const rescanblockchainQueryKey = (options: Options<RescanblockchainData>) =>
  createQueryKey('rescanblockchain', options)

/**
 * Rescan the blockchain from a given blockheight
 * Use this operation on recovered wallets to re-sync the wallet
 */
export const rescanblockchainOptions = (options: Options<RescanblockchainData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rescanblockchain({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: rescanblockchainQueryKey(options),
  })
}

export const getrescaninfoQueryKey = (options: Options<GetrescaninfoData>) => createQueryKey('getrescaninfo', options)

/**
 * get the current rescan status
 * get the current rescan status
 */
export const getrescaninfoOptions = (options: Options<GetrescaninfoData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getrescaninfo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getrescaninfoQueryKey(options),
  })
}

export const gettimelockaddressQueryKey = (options: Options<GettimelockaddressData>) =>
  createQueryKey('gettimelockaddress', options)

/**
 * get a fresh timelock address
 * get a new timelocked address, for depositing funds, to create a fidelity bond, which will automatically be used when the maker is started. specify the date in YYYY-mm as the last path parameter. Note that mixdepth is not specified as timelock addresses are always in mixdepth(account) zero.
 */
export const gettimelockaddressOptions = (options: Options<GettimelockaddressData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await gettimelockaddress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: gettimelockaddressQueryKey(options),
  })
}

export const listutxosQueryKey = (options: Options<ListutxosData>) => createQueryKey('listutxos', options)

/**
 * list details of all utxos currently in the wallet.
 * list details of all utxos currently in the wallet.
 */
export const listutxosOptions = (options: Options<ListutxosData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listutxos({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: listutxosQueryKey(options),
  })
}

export const directsendQueryKey = (options: Options<DirectsendData>) => createQueryKey('directsend', options)

/**
 * create and broadcast a transaction (without coinjoin)
 * create and broadcast a transaction (without coinjoin)
 */
export const directsendOptions = (options: Options<DirectsendData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await directsend({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: directsendQueryKey(options),
  })
}

/**
 * create and broadcast a transaction (without coinjoin)
 * create and broadcast a transaction (without coinjoin)
 */
export const directsendMutation = (
  options?: Partial<Options<DirectsendData>>,
): UseMutationOptions<DirectsendResponse, DirectsendError, Options<DirectsendData>> => {
  const mutationOptions: UseMutationOptions<DirectsendResponse, DirectsendError, Options<DirectsendData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await directsend({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const startmakerQueryKey = (options: Options<StartmakerData>) => createQueryKey('startmaker', options)

/**
 * Start the yield generator service.
 * Start the yield generator service with the configuration settings specified in the POST request. Note that if fidelity bonds are enabled in the wallet, and a timelock address has been generated, and then funded, the fidelity bond will automatically be advertised without any specific configuration in this request. Note that if the wallet does not have confirmed coins, or another taker or maker coinjoin service is already running, the maker will not start.
 */
export const startmakerOptions = (options: Options<StartmakerData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await startmaker({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: startmakerQueryKey(options),
  })
}

/**
 * Start the yield generator service.
 * Start the yield generator service with the configuration settings specified in the POST request. Note that if fidelity bonds are enabled in the wallet, and a timelock address has been generated, and then funded, the fidelity bond will automatically be advertised without any specific configuration in this request. Note that if the wallet does not have confirmed coins, or another taker or maker coinjoin service is already running, the maker will not start.
 */
export const startmakerMutation = (
  options?: Partial<Options<StartmakerData>>,
): UseMutationOptions<unknown, StartmakerError, Options<StartmakerData>> => {
  const mutationOptions: UseMutationOptions<unknown, StartmakerError, Options<StartmakerData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await startmaker({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const stopmakerQueryKey = (options: Options<StopmakerData>) => createQueryKey('stopmaker', options)

/**
 * stop the yield generator service
 * stop the yield generator service
 */
export const stopmakerOptions = (options: Options<StopmakerData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await stopmaker({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: stopmakerQueryKey(options),
  })
}

export const docoinjoinQueryKey = (options: Options<DocoinjoinData>) => createQueryKey('docoinjoin', options)

/**
 * initiate a coinjoin as taker
 * initiate a coinjoin as taker
 */
export const docoinjoinOptions = (options: Options<DocoinjoinData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await docoinjoin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: docoinjoinQueryKey(options),
  })
}

/**
 * initiate a coinjoin as taker
 * initiate a coinjoin as taker
 */
export const docoinjoinMutation = (
  options?: Partial<Options<DocoinjoinData>>,
): UseMutationOptions<unknown, DocoinjoinError, Options<DocoinjoinData>> => {
  const mutationOptions: UseMutationOptions<unknown, DocoinjoinError, Options<DocoinjoinData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await docoinjoin({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getscheduleQueryKey = (options: Options<GetscheduleData>) => createQueryKey('getschedule', options)

/**
 * get the schedule that is currently running
 * Get the current transaction schedule if one is running.
 */
export const getscheduleOptions = (options: Options<GetscheduleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getschedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getscheduleQueryKey(options),
  })
}

export const runscheduleQueryKey = (options: Options<RunscheduleData>) => createQueryKey('runschedule', options)

/**
 * create and run a schedule of transactions
 * Creates and then starts a schedule of transactions.
 */
export const runscheduleOptions = (options: Options<RunscheduleData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await runschedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: runscheduleQueryKey(options),
  })
}

/**
 * create and run a schedule of transactions
 * Creates and then starts a schedule of transactions.
 */
export const runscheduleMutation = (
  options?: Partial<Options<RunscheduleData>>,
): UseMutationOptions<RunscheduleResponse, RunscheduleError, Options<RunscheduleData>> => {
  const mutationOptions: UseMutationOptions<RunscheduleResponse, RunscheduleError, Options<RunscheduleData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await runschedule({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const stopcoinjoinQueryKey = (options: Options<StopcoinjoinData>) => createQueryKey('stopcoinjoin', options)

/**
 * stop a running coinjoin attempt
 * stop a running coinjoin attempt
 */
export const stopcoinjoinOptions = (options: Options<StopcoinjoinData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await stopcoinjoin({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: stopcoinjoinQueryKey(options),
  })
}

export const configsettingQueryKey = (options: Options<ConfigsettingData>) => createQueryKey('configsetting', options)

/**
 * change a config variable
 * change a config variable (for the duration of this backend daemon process instance)
 */
export const configsettingOptions = (options: Options<ConfigsettingData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await configsetting({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: configsettingQueryKey(options),
  })
}

/**
 * change a config variable
 * change a config variable (for the duration of this backend daemon process instance)
 */
export const configsettingMutation = (
  options?: Partial<Options<ConfigsettingData>>,
): UseMutationOptions<ConfigsettingResponse, ConfigsettingError, Options<ConfigsettingData>> => {
  const mutationOptions: UseMutationOptions<ConfigsettingResponse, ConfigsettingError, Options<ConfigsettingData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await configsetting({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const configgetQueryKey = (options: Options<ConfiggetData>) => createQueryKey('configget', options)

/**
 * get the value of a specific config setting
 * Get the value of a specific config setting. Note values are always returned as string.
 */
export const configgetOptions = (options: Options<ConfiggetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await configget({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: configgetQueryKey(options),
  })
}

/**
 * get the value of a specific config setting
 * Get the value of a specific config setting. Note values are always returned as string.
 */
export const configgetMutation = (
  options?: Partial<Options<ConfiggetData>>,
): UseMutationOptions<ConfiggetResponse, ConfiggetError, Options<ConfiggetData>> => {
  const mutationOptions: UseMutationOptions<ConfiggetResponse, ConfiggetError, Options<ConfiggetData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await configget({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const freezeQueryKey = (options: Options<FreezeData>) => createQueryKey('freeze', options)

/**
 * freeze or unfreeze an individual utxo for spending
 * freeze or unfreeze an individual utxo for spending
 */
export const freezeOptions = (options: Options<FreezeData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await freeze({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: freezeQueryKey(options),
  })
}

/**
 * freeze or unfreeze an individual utxo for spending
 * freeze or unfreeze an individual utxo for spending
 */
export const freezeMutation = (
  options?: Partial<Options<FreezeData>>,
): UseMutationOptions<FreezeResponse2, FreezeError, Options<FreezeData>> => {
  const mutationOptions: UseMutationOptions<FreezeResponse2, FreezeError, Options<FreezeData>> = {
    mutationFn: async (localOptions) => {
      const { data } = await freeze({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const getseedQueryKey = (options: Options<GetseedData>) => createQueryKey('getseed', options)

/**
 * get the mnemonic recovery phrase with the optional passphrase
 * Get the mnemonic recovery phrase with the optional passphrase. Not the response is a sentence with few line breaks.
 */
export const getseedOptions = (options: Options<GetseedData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getseed({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: getseedQueryKey(options),
  })
}
