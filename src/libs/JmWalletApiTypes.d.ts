/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/token': {
    /**
     * The token endpoint is used by the client to obtain an access token using a grant such as refresh token
     * @description Give a refresh token and get back both an access and refresh token. On initially creating, unlocking or recovering a wallet, store both the refresh and access tokens, the latter is valid for only 30 minutes (must be used for any authenticated call) while the former is for 4 hours (can only be used in the refresh request parameters). Use /token endpoint on a regular basis to get new access and refresh tokens, ideally before access token expiration to avoid authentication errors and in any case, before refresh token expiration. The newly issued tokens must be used in subsequent calls since operation invalidates previously issued tokens.
     */
    post: operations['token']
  }
  '/wallet/create': {
    /**
     * create a new wallet
     * @description Give a filename (.jmdat must be included) and a password, create the wallet and get back the seedphrase for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. Note that this operation cannot be performed when a wallet is already loaded (unlocked).
     */
    post: operations['createwallet']
  }
  '/wallet/recover': {
    /**
     * recover a wallet from a seedphrase
     * @description Give a filename (.jmdat must be included), a wallettype, a seedphrase and a password, create the wallet for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. The seedphrase must be a single string with words space-separated, and must conform to BIP39 (else 400 is returned). Note that this operation cannot be performed when a wallet is already loaded (unlocked).
     */
    post: operations['recoverwallet']
  }
  '/wallet/{walletname}/unlock': {
    /**
     * decrypt an existing wallet
     * @description Give the password for the specified (existing) wallet file, and it will be decrypted ready for use. Note that this operation cannot be performed when another wallet is already loaded (unlocked).
     */
    post: operations['unlockwallet']
  }
  '/wallet/{walletname}/lock': {
    /**
     * block access to a currently decrypted wallet
     * @description After this (authenticated) action, the wallet will not be readable or writeable.
     */
    get: operations['lockwallet']
  }
  '/wallet/{walletname}/display': {
    /**
     * get detailed breakdown of wallet contents by account.
     * @description get detailed breakdown of wallet contents by account.
     */
    get: operations['displaywallet']
  }
  '/session': {
    /**
     * get current status of backend
     * @description get whether a wallet is loaded and whether coinjoin/maker are happening. if an auth token is provided, which is optional, it will be validated.
     */
    get: operations['session']
  }
  '/getinfo': {
    /**
     * get info on backend
     * @description get information about backend, including the version of Joinmarket running.
     */
    get: operations['version']
  }
  '/wallet/all': {
    /**
     * get current available wallets
     * @description get all wallet filenames in standard location as a list
     */
    get: operations['listwallets']
  }
  '/wallet/yieldgen/report': {
    /**
     * get latest report on yield generating activity
     * @description Get list of coinjoins taken part in as maker (across all wallets). Data returned as list of strings, each one in the same comma separated format as found in yigen-statement.csv. Note that this returns all lines in the file, including the lines that are only present to represent the starting of a bot. Those lines contain the word Connected and can be thus discarded. The header line is also delivered and so can be ignored as per the client requirements.
     */
    get: operations['yieldgenreport']
  }
  '/wallet/{walletname}/address/new/{mixdepth}': {
    /**
     * get a fresh address in the given account for depositing funds.
     * @description get a fresh address in the given account for depositing funds.
     */
    get: operations['getaddress']
  }
  '/wallet/{walletname}/rescanblockchain/{blockheight}': {
    /**
     * Rescan the blockchain from a given blockheight
     * @description Use this operation on recovered wallets to re-sync the wallet
     */
    get: operations['rescanblockchain']
  }
  '/wallet/{walletname}/address/timelock/new/{lockdate}': {
    /**
     * get a fresh timelock address
     * @description get a new timelocked address, for depositing funds, to create a fidelity bond, which will automatically be used when the maker is started. specify the date in YYYY-mm as the last path parameter. Note that mixdepth is not specified as timelock addresses are always in mixdepth(account) zero.
     */
    get: operations['gettimelockaddress']
  }
  '/wallet/{walletname}/utxos': {
    /**
     * list details of all utxos currently in the wallet.
     * @description list details of all utxos currently in the wallet.
     */
    get: operations['listutxos']
  }
  '/wallet/{walletname}/taker/direct-send': {
    /**
     * create and broadcast a transaction (without coinjoin)
     * @description create and broadcast a transaction (without coinjoin)
     */
    post: operations['directsend']
  }
  '/wallet/{walletname}/maker/start': {
    /**
     * Start the yield generator service.
     * @description Start the yield generator service with the configuration settings specified in the POST request. Note that if fidelity bonds are enabled in the wallet, and a timelock address has been generated, and then funded, the fidelity bond will automatically be advertised without any specific configuration in this request. Note that if the wallet does not have confirmed coins, or another taker or maker coinjoin service is already running, the maker will not start.
     */
    post: operations['startmaker']
  }
  '/wallet/{walletname}/maker/stop': {
    /**
     * stop the yield generator service
     * @description stop the yield generator service
     */
    get: operations['stopmaker']
  }
  '/wallet/{walletname}/taker/coinjoin': {
    /**
     * initiate a coinjoin as taker
     * @description initiate a coinjoin as taker
     */
    post: operations['docoinjoin']
  }
  '/wallet/{walletname}/taker/schedule': {
    /**
     * get the schedule that is currently running
     * @description Get the current transaction schedule if one is running.
     */
    get: operations['getschedule']
    /**
     * create and run a schedule of transactions
     * @description Creates and then starts a schedule of transactions.
     */
    post: operations['runschedule']
  }
  '/wallet/{walletname}/taker/stop': {
    /**
     * stop a running coinjoin attempt
     * @description stop a running coinjoin attempt
     */
    get: operations['stopcoinjoin']
  }
  '/wallet/{walletname}/configset': {
    /**
     * change a config variable
     * @description change a config variable (for the duration of this backend daemon process instance)
     */
    post: operations['configsetting']
  }
  '/wallet/{walletname}/configget': {
    /**
     * get the value of a specific config setting
     * @description Get the value of a specific config setting. Note values are always returned as string.
     */
    post: operations['configget']
  }
  '/wallet/{walletname}/freeze': {
    /**
     * freeze or unfreeze an individual utxo for spending
     * @description freeze or unfreeze an individual utxo for spending
     */
    post: operations['freeze']
  }
  '/wallet/{walletname}/getseed': {
    /**
     * get the mnemonic recovery phrase with the optional passphrase
     * @description Get the mnemonic recovery phrase with the optional passphrase. Not the response is a sentence with few line breaks.
     */
    get: operations['getseed']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    FreezeRequest: {
      'utxo-string': string
      freeze: boolean
    }
    ConfigSetRequest: {
      section: string
      field: string
      value: string
    }
    ConfigGetRequest: {
      section: string
      field: string
    }
    ConfigGetResponse: {
      configvalue: string
    }
    ConfigSetResponse: Record<string, never>
    FreezeResponse: Record<string, never>
    DoCoinjoinRequest: {
      /** @example 0 */
      mixdepth: number
      /** @example 100000000 */
      amount_sats: number
      /** @example 9 */
      counterparties: number
      /** @example bcrt1qujp2x2fv437493sm25gfjycns7d39exjnpptzw */
      destination: string
      /**
       * @description Bitcoin miner fee to use for transaction. A number higher than 1000 is used as satoshi per kvB tx fee. The number lower than that uses the dynamic fee estimation of blockchain provider as confirmation target.
       * @example 6
       */
      txfee?: unknown
    }
    TokenRequest: {
      grant_type: string
      refresh_token: string
    }
    TokenResponse: {
      token: string
      token_type: string
      expires_in: number
      scope: string
      refresh_token: string
    }
    RunScheduleRequest: {
      destination_addresses?: string[]
      tumbler_options?: {
        addrcount?: number
        minmakercount?: number
        /**
         * @example [
         *   9,
         *   1
         * ]
         */
        makercountrange?: number[]
        mixdepthcount?: number
        mintxcount?: number
        /**
         * @example [
         *   2,
         *   1
         * ]
         */
        txcountparams?: number[]
        timelambda?: number
        stage1_timelambda_increase?: number
        liquiditywait?: number
        waittime?: number
        mixdepthsrc?: number
        restart?: boolean
        schedulefile?: string
        mincjamount?: number
        amtmixdepths?: number
        rounding_chance?: number
        /**
         * @example [
         *   55,
         *   15,
         *   25,
         *   65,
         *   40
         * ]
         */
        rounding_sigfig_weights?: number[]
      }
    }
    StartMakerRequest: {
      /** @example 0 */
      txfee: string
      /** @example 5000 */
      cjfee_a: string
      /** @example 0.00004 */
      cjfee_r: string
      /** @example reloffer */
      ordertype: string
      /** @example 8000000 */
      minsize: string
    }
    /** @example bcrt1qujp2x2fv437493sm25gfjycns7d39exjnpptzw */
    GetAddressResponse: string
    ListWalletsResponse: {
      wallets?: string[]
    }
    YieldGenReportResponse: string[]
    GetinfoResponse: {
      /** @example 0.9.10 */
      version: string
    }
    RescanBlockchainResponse: {
      /** @example wallet.jmdat */
      walletname: string
    }
    SessionResponse: {
      session: boolean
      maker_running: boolean
      coinjoin_in_process: boolean
      schedule?: (string | number)[][]
      /** @example wallet.jmdat */
      wallet_name: string
      offer_list?: {
        oid?: number
        ordertype?: string
        minsize?: number
        maxsize?: number
        txfee?: number
        cjfee?: string
      }[]
      nickname?: string
      rescanning: boolean
      block_height?: number
    }
    ListUtxosResponse: {
      utxos?: {
        utxo?: string
        address?: string
        path?: string
        label?: string
        value?: number
        tries?: number
        tries_remaining?: number
        external?: boolean
        mixdepth?: number
        confirmations?: number
        frozen?: boolean
      }[]
    }
    WalletDisplayResponse: {
      walletname: string
      walletinfo: {
        wallet_name: string
        total_balance: string
        available_balance?: string
        accounts: {
          account?: string
          account_balance?: string
          available_balance?: string
          branches?: {
            branch?: string
            balance?: string
            available_balance?: string
            entries?: {
              hd_path?: string
              address?: string
              amount?: string
              available_balance?: string
              status?: string
              label?: string
              extradata?: string
            }[]
          }[]
        }[]
      }
    }
    CreateWalletResponse: {
      /** @example wallet.jmdat */
      walletname: string
      seedphrase: string
      /** Format: byte */
      token: string
      /** Format: byte */
      refresh_token: string
    }
    UnlockWalletResponse: {
      /** @example wallet.jmdat */
      walletname: string
      /** Format: byte */
      token: string
      /** Format: byte */
      refresh_token: string
    }
    DirectSendResponse: {
      txinfo: {
        hex?: string
        inputs?: {
          outpoint?: string
          scriptSig?: string
          nSequence?: number
          witness?: string
        }[]
        outputs?: {
          value_sats?: number
          scriptPubKey?: string
          address?: string
        }[]
        txid?: string
        nLockTime?: number
        nVersion?: number
      }
    }
    GetSeedResponse: {
      seedphrase: string
    }
    GetScheduleResponse: {
      schedule: (string | number)[][]
    }
    LockWalletResponse: {
      /** @example wallet.jmdat */
      walletname: string
      /** @example false */
      already_locked: boolean
    }
    CreateWalletRequest: {
      /** @example wallet.jmdat */
      walletname: string
      /**
       * Format: password
       * @example hunter2
       */
      password: string
      /** @example sw-fb */
      wallettype: string
    }
    RecoverWalletRequest: {
      /** @example wallet.jmdat */
      walletname: string
      /**
       * Format: password
       * @example hunter2
       */
      password: string
      /** @example sw-fb */
      wallettype: string
      /** @example abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about */
      seedphrase: string
    }
    UnlockWalletRequest: {
      /**
       * Format: password
       * @example hunter2
       */
      password: string
    }
    DirectSendRequest: {
      /** @example 0 */
      mixdepth: number
      /** @example 100000000 */
      amount_sats: number
      /** @example bcrt1qu7k4dppungsqp95nwc7ansqs9m0z95h72j9mze */
      destination: string
      /**
       * @description Bitcoin miner fee to use for transaction. A number higher than 1000 is used as satoshi per kvB tx fee. The number lower than that uses the dynamic fee estimation of blockchain provider as confirmation target.
       * @example 6
       */
      txfee?: number
    }
    ErrorMessage: {
      message?: string
      error_description?: string
    }
  }
  responses: {
    /** @description transaction broadcast OK. */
    'DirectSend-200-Accepted': {
      content: {
        'application/json': components['schemas']['DirectSendResponse']
      }
    }
    /** @description successful retrieval of utxo list */
    'ListUtxos-200-OK': {
      content: {
        'application/json': components['schemas']['ListUtxosResponse']
      }
    }
    /** @description successful retrieval of config value */
    'ConfigGet-200-OK': {
      content: {
        'application/json': components['schemas']['ConfigGetResponse']
      }
    }
    /** @description successful update of config value */
    'ConfigSet-200-OK': {
      content: {
        'application/json': components['schemas']['ConfigSetResponse']
      }
    }
    /** @description successful retrieval of new address */
    'GetAddress-200-OK': {
      content: {
        'application/json': components['schemas']['GetAddressResponse']
      }
    }
    /** @description successful response to listwallets */
    'ListWallets-200-OK': {
      content: {
        'application/json': components['schemas']['ListWalletsResponse']
      }
    }
    /** @description Access token obtained successfully */
    'Token-200-OK': {
      content: {
        'application/json': components['schemas']['TokenResponse']
      }
    }
    /** @description successful heartbeat response */
    'Session-200-OK': {
      content: {
        'application/json': components['schemas']['SessionResponse']
      }
    }
    /** @description successful Joinmarket getinfo response */
    'Getinfo-200-OK': {
      content: {
        'application/json': components['schemas']['GetinfoResponse']
      }
    }
    /** @description Blockchain rescan started successfully */
    'RescanBlockchain-200-OK': {
      content: {
        'application/json': components['schemas']['RescanBlockchainResponse']
      }
    }
    /** @description wallet created successfully */
    'Create-201-OK': {
      content: {
        'application/json': components['schemas']['CreateWalletResponse']
      }
    }
    /** @description wallet recovered successfully */
    'Recover-201-OK': {
      content: {
        'application/json': components['schemas']['CreateWalletResponse']
      }
    }
    /** @description wallet unlocked successfully */
    'Unlock-200-OK': {
      content: {
        'application/json': components['schemas']['UnlockWalletResponse']
      }
    }
    /** @description wallet display contents retrieved successfully. */
    'Display-200-OK': {
      content: {
        'application/json': components['schemas']['WalletDisplayResponse']
      }
    }
    /** @description wallet locked successfully */
    'Lock-200-OK': {
      content: {
        'application/json': components['schemas']['LockWalletResponse']
      }
    }
    /** @description seedphrase retrieved successfully */
    'GetSeed-200-OK': {
      content: {
        'application/json': components['schemas']['GetSeedResponse']
      }
    }
    /** @description freeze or unfreeze utxo action completed successfully */
    'Freeze-200-OK': {
      content: {
        'application/json': components['schemas']['FreezeResponse']
      }
    }
    /** @description schedule started successfully */
    'RunSchedule-202-OK': {
      content: {
        'application/json': components['schemas']['GetScheduleResponse']
      }
    }
    /** @description schedule retrieved successfully */
    'GetSchedule-200-OK': {
      content: {
        'application/json': components['schemas']['GetScheduleResponse']
      }
    }
    /** @description get list of coinjoins taken part in as maker (across all wallets) */
    'YieldGenReport-200-OK': {
      content: {
        'application/json': components['schemas']['YieldGenReportResponse']
      }
    }
    /** @description The request has been submitted successfully for processing, but the processing has not been completed. */
    '202-Accepted': {
      content: never
    }
    /** @description Bad request format. */
    '400-BadRequest': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description Unable to authorise the credentials that were supplied. */
    '401-Unauthorized': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description Unable to complete request because object already exists. */
    '409-AlreadyExists': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description Unable to complete request because config settings are missing. */
    '409-NoConfig': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description Transaction failed to broadcast. */
    '409-TransactionFailed': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description Maker could not start without confirmed balance. */
    '409-No-Coins': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description Item not found. */
    '404-NotFound': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
    /** @description The server is not ready to process the request. */
    '503-ServiceUnavailable': {
      content: {
        'application/json': components['schemas']['ErrorMessage']
      }
    }
  }
  parameters: never
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * The token endpoint is used by the client to obtain an access token using a grant such as refresh token
   * @description Give a refresh token and get back both an access and refresh token. On initially creating, unlocking or recovering a wallet, store both the refresh and access tokens, the latter is valid for only 30 minutes (must be used for any authenticated call) while the former is for 4 hours (can only be used in the refresh request parameters). Use /token endpoint on a regular basis to get new access and refresh tokens, ideally before access token expiration to avoid authentication errors and in any case, before refresh token expiration. The newly issued tokens must be used in subsequent calls since operation invalidates previously issued tokens.
   */
  token: {
    /** @description token refresh parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['TokenRequest']
      }
    }
    responses: {
      200: components['responses']['Token-200-OK']
      400: components['responses']['400-BadRequest']
    }
  }
  /**
   * create a new wallet
   * @description Give a filename (.jmdat must be included) and a password, create the wallet and get back the seedphrase for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. Note that this operation cannot be performed when a wallet is already loaded (unlocked).
   */
  createwallet: {
    /** @description wallet creation parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateWalletRequest']
      }
    }
    responses: {
      201: components['responses']['Create-201-OK']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      409: components['responses']['409-AlreadyExists']
    }
  }
  /**
   * recover a wallet from a seedphrase
   * @description Give a filename (.jmdat must be included), a wallettype, a seedphrase and a password, create the wallet for the newly persisted wallet file. The wallettype variable must be one of "sw" - segwit native, "sw-legacy" - segwit legacy or "sw-fb" - segwit native with fidelity bonds supported, the last of which is the default. The seedphrase must be a single string with words space-separated, and must conform to BIP39 (else 400 is returned). Note that this operation cannot be performed when a wallet is already loaded (unlocked).
   */
  recoverwallet: {
    /** @description wallet recovery parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['RecoverWalletRequest']
      }
    }
    responses: {
      201: components['responses']['Create-201-OK']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      409: components['responses']['409-AlreadyExists']
    }
  }
  /**
   * decrypt an existing wallet
   * @description Give the password for the specified (existing) wallet file, and it will be decrypted ready for use. Note that this operation cannot be performed when another wallet is already loaded (unlocked).
   */
  unlockwallet: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description wallet unlocking parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['UnlockWalletRequest']
      }
    }
    responses: {
      200: components['responses']['Unlock-200-OK']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      404: components['responses']['404-NotFound']
      409: components['responses']['409-AlreadyExists']
    }
  }
  /**
   * block access to a currently decrypted wallet
   * @description After this (authenticated) action, the wallet will not be readable or writeable.
   */
  lockwallet: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      200: components['responses']['Lock-200-OK']
      400: components['responses']['400-BadRequest']
    }
  }
  /**
   * get detailed breakdown of wallet contents by account.
   * @description get detailed breakdown of wallet contents by account.
   */
  displaywallet: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      200: components['responses']['Display-200-OK']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * get current status of backend
   * @description get whether a wallet is loaded and whether coinjoin/maker are happening. if an auth token is provided, which is optional, it will be validated.
   */
  session: {
    responses: {
      200: components['responses']['Session-200-OK']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * get info on backend
   * @description get information about backend, including the version of Joinmarket running.
   */
  version: {
    responses: {
      200: components['responses']['Getinfo-200-OK']
    }
  }
  /**
   * get current available wallets
   * @description get all wallet filenames in standard location as a list
   */
  listwallets: {
    responses: {
      200: components['responses']['ListWallets-200-OK']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * get latest report on yield generating activity
   * @description Get list of coinjoins taken part in as maker (across all wallets). Data returned as list of strings, each one in the same comma separated format as found in yigen-statement.csv. Note that this returns all lines in the file, including the lines that are only present to represent the starting of a bot. Those lines contain the word Connected and can be thus discarded. The header line is also delivered and so can be ignored as per the client requirements.
   */
  yieldgenreport: {
    responses: {
      200: components['responses']['YieldGenReport-200-OK']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * get a fresh address in the given account for depositing funds.
   * @description get a fresh address in the given account for depositing funds.
   */
  getaddress: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
        /** @description account or mixdepth to source the address from (0..4) */
        mixdepth: string
      }
    }
    responses: {
      200: components['responses']['GetAddress-200-OK']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * Rescan the blockchain from a given blockheight
   * @description Use this operation on recovered wallets to re-sync the wallet
   */
  rescanblockchain: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
        /** @description starting block height for the rescan */
        blockheight: number
      }
    }
    responses: {
      200: components['responses']['RescanBlockchain-200-OK']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * get a fresh timelock address
   * @description get a new timelocked address, for depositing funds, to create a fidelity bond, which will automatically be used when the maker is started. specify the date in YYYY-mm as the last path parameter. Note that mixdepth is not specified as timelock addresses are always in mixdepth(account) zero.
   */
  gettimelockaddress: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
        /** @description month whose first day will be the end of the timelock, for this address. */
        lockdate: string
      }
    }
    responses: {
      200: components['responses']['GetAddress-200-OK']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * list details of all utxos currently in the wallet.
   * @description list details of all utxos currently in the wallet.
   */
  listutxos: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      200: components['responses']['ListUtxos-200-OK']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * create and broadcast a transaction (without coinjoin)
   * @description create and broadcast a transaction (without coinjoin)
   */
  directsend: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description transaction creation parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['DirectSendRequest']
      }
    }
    responses: {
      200: components['responses']['DirectSend-200-Accepted']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
      409: components['responses']['409-TransactionFailed']
    }
  }
  /**
   * Start the yield generator service.
   * @description Start the yield generator service with the configuration settings specified in the POST request. Note that if fidelity bonds are enabled in the wallet, and a timelock address has been generated, and then funded, the fidelity bond will automatically be advertised without any specific configuration in this request. Note that if the wallet does not have confirmed coins, or another taker or maker coinjoin service is already running, the maker will not start.
   */
  startmaker: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description yield generator config parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['StartMakerRequest']
      }
    }
    responses: {
      202: components['responses']['202-Accepted']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      404: components['responses']['404-NotFound']
      409: components['responses']['409-No-Coins']
      503: components['responses']['503-ServiceUnavailable']
    }
  }
  /**
   * stop the yield generator service
   * @description stop the yield generator service
   */
  stopmaker: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      202: components['responses']['202-Accepted']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * initiate a coinjoin as taker
   * @description initiate a coinjoin as taker
   */
  docoinjoin: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description taker side coinjoin parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['DoCoinjoinRequest']
      }
    }
    responses: {
      202: components['responses']['202-Accepted']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      404: components['responses']['404-NotFound']
      409: components['responses']['409-NoConfig']
      503: components['responses']['503-ServiceUnavailable']
    }
  }
  /**
   * get the schedule that is currently running
   * @description Get the current transaction schedule if one is running.
   */
  getschedule: {
    parameters: {
      path: {
        /** @description name of the wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      200: components['responses']['GetSchedule-200-OK']
      400: components['responses']['400-BadRequest']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * create and run a schedule of transactions
   * @description Creates and then starts a schedule of transactions.
   */
  runschedule: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description taker side schedule parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['RunScheduleRequest']
      }
    }
    responses: {
      202: components['responses']['RunSchedule-202-OK']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      404: components['responses']['404-NotFound']
      409: components['responses']['409-NoConfig']
      503: components['responses']['503-ServiceUnavailable']
    }
  }
  /**
   * stop a running coinjoin attempt
   * @description stop a running coinjoin attempt
   */
  stopcoinjoin: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      202: components['responses']['202-Accepted']
      400: components['responses']['400-BadRequest']
      401: components['responses']['401-Unauthorized']
      404: components['responses']['404-NotFound']
    }
  }
  /**
   * change a config variable
   * @description change a config variable (for the duration of this backend daemon process instance)
   */
  configsetting: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description config editing parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['ConfigSetRequest']
      }
    }
    responses: {
      200: components['responses']['ConfigSet-200-OK']
      400: components['responses']['400-BadRequest']
      409: components['responses']['409-NoConfig']
    }
  }
  /**
   * get the value of a specific config setting
   * @description Get the value of a specific config setting. Note values are always returned as string.
   */
  configget: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    requestBody?: {
      content: {
        'application/json': components['schemas']['ConfigGetRequest']
      }
    }
    responses: {
      200: components['responses']['ConfigGet-200-OK']
      400: components['responses']['400-BadRequest']
      409: components['responses']['409-NoConfig']
    }
  }
  /**
   * freeze or unfreeze an individual utxo for spending
   * @description freeze or unfreeze an individual utxo for spending
   */
  freeze: {
    parameters: {
      path: {
        /** @description name of wallet including .jmdat */
        walletname: string
      }
    }
    /** @description utxo string and freeze toggle as boolean */
    requestBody?: {
      content: {
        'application/json': components['schemas']['FreezeRequest']
      }
    }
    responses: {
      200: components['responses']['Freeze-200-OK']
      400: components['responses']['400-BadRequest']
    }
  }
  /**
   * get the mnemonic recovery phrase with the optional passphrase
   * @description Get the mnemonic recovery phrase with the optional passphrase. Not the response is a sentence with few line breaks.
   */
  getseed: {
    parameters: {
      path: {
        /** @description name of the wallet including .jmdat */
        walletname: string
      }
    }
    responses: {
      200: components['responses']['GetSeed-200-OK']
      400: components['responses']['400-BadRequest']
    }
  }
}
